// Options for JavaCC.
options { LOOKAHEAD=1; FORCE_LA_CHECK=true; }

// Fonction principale
PARSER_BEGIN(Jagger)
public class Jagger
{
    public static void main(String args[]) throws ParseException
    {
        Jagger parser = new Jagger(System.in);
        parser.mainloop();
    }
}
PARSER_END(Jagger)

// Characters to ignore.
SKIP: { " " | "\r" | "\t" }

// Token specifications.
TOKEN:
{
    < NUMBER: (<DIGIT>)+ ("." (<DIGIT>)*)? >  // A decimal number.
|   < DIGIT: ["0"-"9"] >                      // A decimal digit.
|   < VARIABLE: ["a"-"z", "A"-"Z"](["a"-"z", "A"-"Z","0"-"9"])* >   // Variable

|   <ASSIGN: ":=">                           // Assignement
|   <LB: "(">                                // Left bracket
|   <RB: ")">                                // Right bracket

|   <PRINT: "print">                         // Print

|   < EOL: "\n" >                            // End of line.
}

// Main lopp: read expressions on a line until end of file.
//     mainloop → (expression <EOL>)* <EOF>
void mainloop():
{ double a; }
{
    (
      a=expression() <EOL> { System.out.println(a); }
    )*
    <EOF>
}

//Statement
//statement → print | comparison
Expression statement():
{Token t, Expression a}
{
 t = <VARIABLE> <ASSIGN>(a=comparison() { a=new Assignment(t.toString(), a, parent); }
 | a = comparison()
 | a = print()
 )
}

//print
// print -> print(comparison())
Expression print():
{Expression a}
{
    <PRINT> <LB> a = comparison() <RB> {new Print(a)}
}

// Expression (the axiom).
// E -> T ('+'T | '-'T)*
Expression expression():
{ Expression a,b; }
{
    a=term()
    (
      "+" b=expression() { a=new Add(a,b); }
    | "-" b=expression() { a=new Sub(a,b); }
    )? { return a; }
}

// Term.
// T -> U ('*'U | '/'U)*
Expression term():
{ Expression a,b; }
{
    a=factor()
    (
      "*" b=factor() { a=new Mult(a,b); }
    | "/" b=factor() { a=new Div(a,b) }
    )* { return a; }
}


//Unary expression
// U -> "-" F | ("+")?F
Expression unary():
{Expression a}
{
    (
    "-" factor() {a=new Neg(a);}
    | ("+")? factor()
    ){return a;}
}

// Factor of an expression.
// F -> <NUMBER> | "(" E ")"
Expression factor():
{ Token t; double e; }
{
      t=<NUMBER> { return Double.parseDouble(t.toString()); }
    | "(" e=expression() ")" { return e; }
}