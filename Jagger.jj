// Options for JavaCC.
options { LOOKAHEAD=1; FORCE_LA_CHECK=true; }

// Fonction principale
PARSER_BEGIN(Jagger)

import java.util.ArrayList;
import java.util.HashMap;

public class Jagger
{
    public static void main(String args[]) throws ParseException
    {
        Jagger parser = new Jagger(System.in);
        parser.mainloop();
    }
}
PARSER_END(Jagger)

// Characters to ignore.
SKIP: { " " | "\r" | "\t" }

// Token specifications.
TOKEN:
{

    <PRINT: "print">                                                // Print
|   <LRB: "(">                                                      // Left round bracket
|   <RRB: ")">                                                      // Right round bracket

|    <IF: "if">
|    <THEN: "then">
|    <ELSE: "else">

|   <ASSIGN: ":=">                                                  // Assignement



|   < EOL: "\n" >                                                   // End of line.

// Type
|    < NUMBER: (<DIGIT>)+ ("." (<DIGIT>)*)? >                       // A decimal number.
|   < STRING: "\"" ((~["\n", "\r", "\""])*)? "\"" >                 // string
|   < DIGIT: ["0"-"9"] >                                            // A decimal digit.
|   < VARIABLE: ["a"-"z", "A"-"Z"](["a"-"z", "A"-"Z","0"-"9"])* >   // Variable
}

// Main lopp: read expressions on a line until end of file.
//     mainloop → (expression <EOL>)* <EOF>
void mainloop():
{ Expression a; }
{
    (
      (a=print()|a=ITE()) <EOL> { new PrettyPrinter(a); System.out.println(); new Evaluator(a);}
    )*
    <EOF>
}

//Statement
//statement → print | comparison
Expression statement():
{Token t; Expression a;}
{
 (a = comparison()
 | a = print())
 {return a;}
 }

//Print.
// print -> print(comparison())
Expression print():
{Expression a;}
{
    <PRINT><LRB> a = comparison() <RRB> {return new Print(a);}
}

// Comparison operators.
// C -> E ('=='E | '<>'E | '>'E | '<'E | '>='E | '<='E)*
Expression comparison():
{ Expression a,b; }
{
    
    a=expression()
    (
      "=="  b=expression()  { a = new Equal(a,b); }
    | "<>"  b=expression()  { a = new NonEqual(a,b); }
    | ">"   b=expression()  { a = new Sup(a,b); }
    | "<"   b=expression()  { a = new Inf(a,b); }
    | ">="  b=expression()  { a = new SupEqual(a,b); }
    | "<="  b=expression()  { a = new InfEqual(a,b); }
    )?
    { return a; }
}

// Expression (the axiom).
// E -> T ('+'T | '-'T)*
Expression expression():
{ Expression a,b; }
{
    a=term()
    (
      "+" b=term() { a=new Add(a,b); }
    | "-" b=term() { a=new Sub(a,b); }
    )? { return a; }
}

// Term.
// T -> U ('*'U | '/'U)*
Expression term():
{ Expression a,b; }
{
    a=unary()
    (
      "*" b=term() { a=new Mul(a,b); }
    | "/" b=term() { a=new Div(a,b); }
    )* { return a; }
}


//Unary expression
// U -> "-" F | ("+")?F
Expression unary():
{Expression a;}
{
    (
    "-" a=factor() {a=new Neg(a);}
    | ("+")? a=factor()
    ){return a;}
}

// Factor of an expression.
// F -> <NUMBER> | "(" E ")"
Expression factor():
{ Token t; Expression a; }
{
      (t=<NUMBER> {a = new Num(Double.parseDouble(t.toString())); }
    | t=<STRING> { a = new Char(t.toString()); }
    | <LRB> a=comparison() <RRB>)
    { return a; }
   
}

Expression ITE():
{Expression a,b,c;}
{
    (<IF> a=comparison() <THEN> b=comparison() <ELSE> c=comparison() { a = new IfThenElse(a,b,c);})+
    {return a;}
}
